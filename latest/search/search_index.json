{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Under development This tool is still under active development. Spellmatch is a command-line tool for spatial cell representation matching in segmented 2D images. Its main use case is multi-panel imaging, where consecutive tissue slices are imaged with partially overlapping panels, e.g. to enhance multiplexity. Spellmatch matches spatial cell representations Unlike other approaches, spellmatch is not meant for matching similar cells, but matches different representations of the same cell . Importantly, spellmatch only includes algorithms for spatial cell matching, i.e. algorithms that consider the spatial distributions of cells in tissue. Overview \u00b6 Spellmatch provides the following functionality: Interactive cell matching for ground truth generation and initial image alignment Automatic feature/intensity-based image registration for refining image alignments Point set registration for matching cells based on their spatial distribution alone Network alignment for matching cells based on their topology and attributes (e.g. intensities) Extraction of directed and/or undirected cell-cell assignments from cell alignment scores Notably, spellmatch ships with its own network alignment algorithm, which leverages the full information present in multichannel images to obtain cell alignment scores. For an overview of all matching algorithms implemented in spellmatch, please refer to Algorithms . For developers, spellmatch can also be used as a Python package, e.g. to extend spellmatch or to integrate it into custom pipelines. Please refer to Reference for a detailed API documentation Experiments \u00b6 To ensure spellmatch yields high-quality results, your dataset needs to meet certain experimental requirements. Please refer to Protocol for instructions related to data acquisition protocols. Getting started \u00b6 Install spellmatch Use spellmatch Getting help \u00b6 A manuscript is in preparation. For conceptual questions, please do not hesitate to reach out . For technical issues, please refer to the spellmatch issue tracker . Citing spellmatch \u00b6 A manuscript is in preparation. If you are using spellmatch in your work, please reach out to inquire how to best cite the tool.","title":"Welcome"},{"location":"#welcome","text":"Under development This tool is still under active development. Spellmatch is a command-line tool for spatial cell representation matching in segmented 2D images. Its main use case is multi-panel imaging, where consecutive tissue slices are imaged with partially overlapping panels, e.g. to enhance multiplexity. Spellmatch matches spatial cell representations Unlike other approaches, spellmatch is not meant for matching similar cells, but matches different representations of the same cell . Importantly, spellmatch only includes algorithms for spatial cell matching, i.e. algorithms that consider the spatial distributions of cells in tissue.","title":"Welcome"},{"location":"#overview","text":"Spellmatch provides the following functionality: Interactive cell matching for ground truth generation and initial image alignment Automatic feature/intensity-based image registration for refining image alignments Point set registration for matching cells based on their spatial distribution alone Network alignment for matching cells based on their topology and attributes (e.g. intensities) Extraction of directed and/or undirected cell-cell assignments from cell alignment scores Notably, spellmatch ships with its own network alignment algorithm, which leverages the full information present in multichannel images to obtain cell alignment scores. For an overview of all matching algorithms implemented in spellmatch, please refer to Algorithms . For developers, spellmatch can also be used as a Python package, e.g. to extend spellmatch or to integrate it into custom pipelines. Please refer to Reference for a detailed API documentation","title":"Overview"},{"location":"#experiments","text":"To ensure spellmatch yields high-quality results, your dataset needs to meet certain experimental requirements. Please refer to Protocol for instructions related to data acquisition protocols.","title":"Experiments"},{"location":"#getting-started","text":"Install spellmatch Use spellmatch","title":"Getting started"},{"location":"#getting-help","text":"A manuscript is in preparation. For conceptual questions, please do not hesitate to reach out . For technical issues, please refer to the spellmatch issue tracker .","title":"Getting help"},{"location":"#citing-spellmatch","text":"A manuscript is in preparation. If you are using spellmatch in your work, please reach out to inquire how to best cite the tool.","title":"Citing spellmatch"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 0.1.0 - 2022-05-19 \u00b6 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#010-2022-05-19","text":"Initial release","title":"0.1.0 - 2022-05-19"},{"location":"contributing/","text":"Contributing \u00b6 Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate. Extending spellmatch \u00b6 Spellmatch uses pluggy to discover and interface with plugins. Currently, spellmatch supports the addition of custom mask matching algorithms. To add your mask matching algorithm to spellmatch, create a Python package named spellmatch-youralgorithm , configure your setuptools entrypoint for pluggy, and implement the spellmatch.hookspecs.spellmatch_get_mask_matching_algorithm hook. Please refer to the spellmatch reference documentation for further details.","title":"Contributing"},{"location":"contributing/#contributing","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate.","title":"Contributing"},{"location":"contributing/#extending-spellmatch","text":"Spellmatch uses pluggy to discover and interface with plugins. Currently, spellmatch supports the addition of custom mask matching algorithms. To add your mask matching algorithm to spellmatch, create a Python package named spellmatch-youralgorithm , configure your setuptools entrypoint for pluggy, and implement the spellmatch.hookspecs.spellmatch_get_mask_matching_algorithm hook. Please refer to the spellmatch reference documentation for further details.","title":"Extending spellmatch"},{"location":"installation/","text":"Installation \u00b6 Spellmatch is implemented in Python and shipped as a Python package. Requirements \u00b6 The spellmatch Python package requires Python 3.9. For opening analysis notebooks, JupyterLab is recommended. Using virtual environments (e.g. conda ) is strongly recommended for reproducibility reasons. Installation \u00b6 You can install spellmatch from PyPI using pip : pip install spellmatch The latest development version can be installed directly from GitHub : pip install git+https://github.com/bodenmillergroup/spellmatch","title":"Installation"},{"location":"installation/#installation","text":"Spellmatch is implemented in Python and shipped as a Python package.","title":"Installation"},{"location":"installation/#requirements","text":"The spellmatch Python package requires Python 3.9. For opening analysis notebooks, JupyterLab is recommended. Using virtual environments (e.g. conda ) is strongly recommended for reproducibility reasons.","title":"Requirements"},{"location":"installation/#installation_1","text":"You can install spellmatch from PyPI using pip : pip install spellmatch The latest development version can be installed directly from GitHub : pip install git+https://github.com/bodenmillergroup/spellmatch","title":"Installation"},{"location":"license/","text":"License \u00b6 Copyright (c) 2022 University of Zurich Spellmatch is licensed under the MIT License. https://github.com/BodenmillerGroup/spellmatch/blob/main/LICENSE","title":"License"},{"location":"license/#license","text":"Copyright (c) 2022 University of Zurich Spellmatch is licensed under the MIT License. https://github.com/BodenmillerGroup/spellmatch/blob/main/LICENSE","title":"License"},{"location":"algorithms/","text":"Overview \u00b6 All matching algorithms implemented in spellmatch share a common interface. Algorithm types \u00b6 There are three main types of matching algorithms implemented in spellmatch: Mask matching algorithms take pairs of cell masks and, optionally, single- or multichannel images matching in width and height to produce cell alignment scores. The two masks (images) are expected to approximately align (co-register) in physical space; their physical alignment can be specified using a projective transform . Points matching algorithms take pairs of points (i.e., sets of spatial cell coordinates) and, optionally, corresponding single-cell intensities to produce cell alignment scores. The two sets of points are expected to approximately align (co-register) in physical space; their physical alignment can be specified using a projective transform . Bounding boxes may be specified to exclude non-overlapping spatial regions from the matching process. Graph matching algorithms take pairs of spatial cell graphs (i.e., adjacency matrices) to produce cell alignment scores. Optionally, these cell graphs can be attributed : single-cell intensities can be specified as node features, and spatial cell-cell distances can be specified as edge features. In general, graph matching algorithms do not consider spatial alignment per se , however, when used in points matching mode (see below), they may take spatial alignment into consideration. Algorithm polymorphism \u00b6 By constructing (attributed) graphs from sets of spatial cell coordinates and, optionally, corresponding single-cell intensities, every graph matching algorithm may be used in a points matching setting ( points matching mode ). Similarly, by extracting spatial cell coordinates and, optionally, corresponding single-cell intensities from pairs of masks (images), every points matching algorithm may be used in a mask matching setting ( mask matching mode ). This hierarchy is also reflected in the following class diagram, where children inherit all functionality from their parents: classDiagram MatchingAlgorithm <|-- MaskMatchingAlgorithm MaskMatchingAlgorithm <|-- PointsMatchingAlgorithm PointsMatchingAlgorithm <|-- GraphMatchingAlgorithm class MaskMatchingAlgorithm{ +match_masks(source_mask, target_mask, source_img, target_img, prior_transform) } class PointsMatchingAlgorithm{ -outlier_dist -point_feature -intensity_feature -intensity_transform +match_points(source_points, target_points, source_bbox, target_bbox, source_intensities, target_intensities, prior_transform) } class GraphMatchingAlgorithm{ -filter_outliers -adj_radius +match_graphs(source_adj, target_adj, source_dists, target_dists,source_intensities, target_intensities) } Iterative algorithms \u00b6 In addition, iterative variants of the points matching and graph matching algorithms exist: IterativePointsMatchingAlgorithm IterativeGraphMatchingAlgorithm As their name suggests, these algorithms iteratively refine a spatial transform by matching cells, adding a geometric constraint (cf. image co-registration) to the matching problem. Note that not every points matching/graph matching algorithm may be used in an iterative setting, as support for matching priors is required to this end. Please refer to (Ravindra et al., 2019) for further conceptual information.","title":"Overview"},{"location":"algorithms/#overview","text":"All matching algorithms implemented in spellmatch share a common interface.","title":"Overview"},{"location":"algorithms/#algorithm-types","text":"There are three main types of matching algorithms implemented in spellmatch: Mask matching algorithms take pairs of cell masks and, optionally, single- or multichannel images matching in width and height to produce cell alignment scores. The two masks (images) are expected to approximately align (co-register) in physical space; their physical alignment can be specified using a projective transform . Points matching algorithms take pairs of points (i.e., sets of spatial cell coordinates) and, optionally, corresponding single-cell intensities to produce cell alignment scores. The two sets of points are expected to approximately align (co-register) in physical space; their physical alignment can be specified using a projective transform . Bounding boxes may be specified to exclude non-overlapping spatial regions from the matching process. Graph matching algorithms take pairs of spatial cell graphs (i.e., adjacency matrices) to produce cell alignment scores. Optionally, these cell graphs can be attributed : single-cell intensities can be specified as node features, and spatial cell-cell distances can be specified as edge features. In general, graph matching algorithms do not consider spatial alignment per se , however, when used in points matching mode (see below), they may take spatial alignment into consideration.","title":"Algorithm types"},{"location":"algorithms/#algorithm-polymorphism","text":"By constructing (attributed) graphs from sets of spatial cell coordinates and, optionally, corresponding single-cell intensities, every graph matching algorithm may be used in a points matching setting ( points matching mode ). Similarly, by extracting spatial cell coordinates and, optionally, corresponding single-cell intensities from pairs of masks (images), every points matching algorithm may be used in a mask matching setting ( mask matching mode ). This hierarchy is also reflected in the following class diagram, where children inherit all functionality from their parents: classDiagram MatchingAlgorithm <|-- MaskMatchingAlgorithm MaskMatchingAlgorithm <|-- PointsMatchingAlgorithm PointsMatchingAlgorithm <|-- GraphMatchingAlgorithm class MaskMatchingAlgorithm{ +match_masks(source_mask, target_mask, source_img, target_img, prior_transform) } class PointsMatchingAlgorithm{ -outlier_dist -point_feature -intensity_feature -intensity_transform +match_points(source_points, target_points, source_bbox, target_bbox, source_intensities, target_intensities, prior_transform) } class GraphMatchingAlgorithm{ -filter_outliers -adj_radius +match_graphs(source_adj, target_adj, source_dists, target_dists,source_intensities, target_intensities) }","title":"Algorithm polymorphism"},{"location":"algorithms/#iterative-algorithms","text":"In addition, iterative variants of the points matching and graph matching algorithms exist: IterativePointsMatchingAlgorithm IterativeGraphMatchingAlgorithm As their name suggests, these algorithms iteratively refine a spatial transform by matching cells, adding a geometric constraint (cf. image co-registration) to the matching problem. Note that not every points matching/graph matching algorithm may be used in an iterative setting, as support for matching priors is required to this end. Please refer to (Ravindra et al., 2019) for further conceptual information.","title":"Iterative algorithms"},{"location":"algorithms/graph_matching/","text":"Graph matching \u00b6 Under construction This page is still under construction. Spellmatch \u00b6 Windhager and Bodenmiller, 2022 (in preparation) The Spellmatch algorithm is based on the FINAL algorithm for attributed network alignment ( Zhang and Tong, 2018 ). It operates under the assumption that the tissue topology as given by spatial cell graphs is preserved across neighboring tissue sections. In addition to tissue topology, it considers cell features (number of neighbors, intensities) and spatial cell-cell distances to yield a globally optimal matching. Notably, the Spellmatch algorithm adopts the MARIO ( Zhu et al., 2021 ) strategy for balancing similarity scores computed from cell intensity information of shared (intersection) and combined (union) markers. The Spellmatch algorithm is an iterative algorithm. As such, it can take the initial spatial alignment (cf. image co-registration) as a weighted prior for matching cells, while still allowing for matches that may not be captured by the prior. Furthermore, the Spellmatch algorithm can be constrained to only match cells in spatial proximity. The Spellmatch algorithm and the Iterative Closest Points (ICP) algorithm By setting all weights to 0 , or by setting alpha to 0 , the Spellmatch algorithm approximately converges to the Iterative Closest Points (ICP) algorithm. The Spellmatch algorithm and the Generalized Assignment Problem (GAP) The adj_radius parameter controls the neighborhood radius of a cell. In theory, by setting this parameter to infinity (or to a value larger than the diagonal of the larger image), the Spellmatch algorithm converges to a solver for the generalized assignment problem (GAP) . In other words, the Spellmatch algorithm can be seen as a GAP solver, with a search space constrained to the local neighborhood of cells. Parameter Default value Description point_feature centroid scikit-image region property for spatial coordinates intensity_feature intensity_mean scikit-image region property for cell intensities intensity_transform Intensity transform function, e.g. numpy.arcsinh transform_type rigid Spatial transform model ( rigid , similarity , affine ) transform_estim_type max_score Transform estimation strategy ( max_score , max_margin ) transform_estim_k_best 50 Number of points to use for estimating transforms max_iter 10 Number of iterations (transform estimations) scores_tol Frobenius tolerance for changes in scores matrix transform_tol Frobenius tolerance for changes in transform matrix filter_outliers True Whether to include outliers ( strongly recommended ) adj_radius 15 Physical radius in which to consider cells neighbors alpha 0.8 Spatial prior importance [0..very important, 1..ignore] degree_weight intensity_weight celldist_weight 0 0 0 Relative contributions (weights) of cell degree (number of neighbors), cell intensity, and cell-cell distance degree_cdiff_thres 3 Degree cross-difference threshold shared_intensity... pca_n_components 5 Principal components analysis (PCA) configuration for computing the shared intensity feature cross-distance full_intensity_... cca_fit_k_closest fit_k_most_certain cca_n_components 500 100 10 Canonical Correlation Analysis (CCA) configuration for computing the full intensity feature cross-distance intensity_interp_... lmd cca_n_components 11 10 Parameters for shared/full intensity feature cross-distance interpolation (weighting) spatial_cdist_ prior_thres Distance threshold for the spatial cross-distance prior max_spatial_cdist Constraint for only matching cells in spatial proximity cca_max_iter cca_tol 500 1.0e-6 Shared Canonical Correlation Analysis (CCA) parameters opt_max_iter opt_tol 100 1.0e-9 Parameters for the iterative optimization scheme","title":"Graph matching"},{"location":"algorithms/graph_matching/#graph-matching","text":"Under construction This page is still under construction.","title":"Graph matching"},{"location":"algorithms/graph_matching/#spellmatch","text":"Windhager and Bodenmiller, 2022 (in preparation) The Spellmatch algorithm is based on the FINAL algorithm for attributed network alignment ( Zhang and Tong, 2018 ). It operates under the assumption that the tissue topology as given by spatial cell graphs is preserved across neighboring tissue sections. In addition to tissue topology, it considers cell features (number of neighbors, intensities) and spatial cell-cell distances to yield a globally optimal matching. Notably, the Spellmatch algorithm adopts the MARIO ( Zhu et al., 2021 ) strategy for balancing similarity scores computed from cell intensity information of shared (intersection) and combined (union) markers. The Spellmatch algorithm is an iterative algorithm. As such, it can take the initial spatial alignment (cf. image co-registration) as a weighted prior for matching cells, while still allowing for matches that may not be captured by the prior. Furthermore, the Spellmatch algorithm can be constrained to only match cells in spatial proximity. The Spellmatch algorithm and the Iterative Closest Points (ICP) algorithm By setting all weights to 0 , or by setting alpha to 0 , the Spellmatch algorithm approximately converges to the Iterative Closest Points (ICP) algorithm. The Spellmatch algorithm and the Generalized Assignment Problem (GAP) The adj_radius parameter controls the neighborhood radius of a cell. In theory, by setting this parameter to infinity (or to a value larger than the diagonal of the larger image), the Spellmatch algorithm converges to a solver for the generalized assignment problem (GAP) . In other words, the Spellmatch algorithm can be seen as a GAP solver, with a search space constrained to the local neighborhood of cells. Parameter Default value Description point_feature centroid scikit-image region property for spatial coordinates intensity_feature intensity_mean scikit-image region property for cell intensities intensity_transform Intensity transform function, e.g. numpy.arcsinh transform_type rigid Spatial transform model ( rigid , similarity , affine ) transform_estim_type max_score Transform estimation strategy ( max_score , max_margin ) transform_estim_k_best 50 Number of points to use for estimating transforms max_iter 10 Number of iterations (transform estimations) scores_tol Frobenius tolerance for changes in scores matrix transform_tol Frobenius tolerance for changes in transform matrix filter_outliers True Whether to include outliers ( strongly recommended ) adj_radius 15 Physical radius in which to consider cells neighbors alpha 0.8 Spatial prior importance [0..very important, 1..ignore] degree_weight intensity_weight celldist_weight 0 0 0 Relative contributions (weights) of cell degree (number of neighbors), cell intensity, and cell-cell distance degree_cdiff_thres 3 Degree cross-difference threshold shared_intensity... pca_n_components 5 Principal components analysis (PCA) configuration for computing the shared intensity feature cross-distance full_intensity_... cca_fit_k_closest fit_k_most_certain cca_n_components 500 100 10 Canonical Correlation Analysis (CCA) configuration for computing the full intensity feature cross-distance intensity_interp_... lmd cca_n_components 11 10 Parameters for shared/full intensity feature cross-distance interpolation (weighting) spatial_cdist_ prior_thres Distance threshold for the spatial cross-distance prior max_spatial_cdist Constraint for only matching cells in spatial proximity cca_max_iter cca_tol 500 1.0e-6 Shared Canonical Correlation Analysis (CCA) parameters opt_max_iter opt_tol 100 1.0e-9 Parameters for the iterative optimization scheme","title":"Spellmatch"},{"location":"algorithms/points_matching/","text":"Points matching \u00b6 Under construction This page is still under construction. Iterative Closest Points (ICP) \u00b6 Besl and McKay, 1992 Implementation based on simpleICP Coherent Point Drift (CPD) \u00b6 Myronenko and Song, 2010 Implemented using probreg Variants: rigid, affine, non-rigid Gaussian Filter Registration (FilterReg) \u00b6 Gao and Tedrake, 2018 Implemented using probreg Variants: rigid, deformable kinematic Bayesian Coherent Point Drift (BCPD) \u00b6 Hirose, 2021 Implemented using probreg Gaussian Mixture Models Registration (GMMReg) \u00b6 Jian and Vemuri, 2005 Implemented using probreg Variants: rigid, TPS Support Vector Registration (SVR) \u00b6 Campbell and Petersson, 2015 Implemented using probreg Variants: rigid, TPS Gaussian Mixture Model Trees Registration (GMMTree) \u00b6 Eckart et al., 2018 Implemented using probreg","title":"Points matching"},{"location":"algorithms/points_matching/#points-matching","text":"Under construction This page is still under construction.","title":"Points matching"},{"location":"algorithms/points_matching/#iterative-closest-points-icp","text":"Besl and McKay, 1992 Implementation based on simpleICP","title":"Iterative Closest Points (ICP)"},{"location":"algorithms/points_matching/#coherent-point-drift-cpd","text":"Myronenko and Song, 2010 Implemented using probreg Variants: rigid, affine, non-rigid","title":"Coherent Point Drift (CPD)"},{"location":"algorithms/points_matching/#gaussian-filter-registration-filterreg","text":"Gao and Tedrake, 2018 Implemented using probreg Variants: rigid, deformable kinematic","title":"Gaussian Filter Registration (FilterReg)"},{"location":"algorithms/points_matching/#bayesian-coherent-point-drift-bcpd","text":"Hirose, 2021 Implemented using probreg","title":"Bayesian Coherent Point Drift (BCPD)"},{"location":"algorithms/points_matching/#gaussian-mixture-models-registration-gmmreg","text":"Jian and Vemuri, 2005 Implemented using probreg Variants: rigid, TPS","title":"Gaussian Mixture Models Registration (GMMReg)"},{"location":"algorithms/points_matching/#support-vector-registration-svr","text":"Campbell and Petersson, 2015 Implemented using probreg Variants: rigid, TPS","title":"Support Vector Registration (SVR)"},{"location":"algorithms/points_matching/#gaussian-mixture-model-trees-registration-gmmtree","text":"Eckart et al., 2018 Implemented using probreg","title":"Gaussian Mixture Model Trees Registration (GMMTree)"},{"location":"reference/","text":"Overview \u00b6 Under construction This page is still under construction.","title":"Overview"},{"location":"reference/#overview","text":"Under construction This page is still under construction.","title":"Overview"},{"location":"usage/","text":"Introduction \u00b6 In this chapter, the usage of spellmatch is introduced by example. The dataset being showcased can be found in the spellmatch repository (subset of Kuett & Catena et al, 2021). Workflow \u00b6 The following flowchart illustrates the spellmatch workflow. Blue rectangles indicate steps , yellow boxes represent modules . Cylinders indicate input and output data of the workflow. flowchart TB source_data[(\"Source data<br>(masks, images, panel)\")] --> initial_registration target_data[(\"Target data<br>(masks, images, panel)\")] --> initial_registration subgraph Registration initial_registration[\"Interactive cell matching\"] refined_registration[\"Feature/intensity-based<br>image registration\"] initial_registration -->|\"initial transform\"| refined_registration end source_data --> matching refined_registration -->|\"refined transform<br>(spatial prior, optional)\"| matching target_data --> matching subgraph Spatial cell matching matching[Automatic cell matching] transform_update[\"Transform estimation<br>(iterative algorithms)\"] matching -->|cell alignment scores| transform_update transform_update -->|updated transform| matching end initial_registration -->|\"partial assignment<br>(for validation, optional)\"| assignment matching -->|alignment scores| assignment assignment[\"Cell assignment\"] assignment --> cell_pairs[(\"Cell assignment\")] Usage \u00b6 Spellmatch can be used from the command-line (terminal in Linux/MacOS, console in Windows): \u276f spellmatch --help Usage: spellmatch [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. Commands: ... ... Most spellmatch commands support a -v option for enabling more verbose output. In addition, many spellmatch commands support a --show option for visualizing the current operation. At any point, use the --help option to display additional information about a specific command. All spellmatch commands can operate on individual file pairs as well as on entire directories. Input \u00b6 Spellmatch requires pairs of source data and target data, where source/target data consist of: Cell masks (TIFF files of any data type) Single- or multichannel images (TIFF files of any data type, optional) For multichannel images: panel with channel information (CSV files, in channel order) Column headers: name (channel name, unique), keep ( 0 or 1 , optional) Images and corresponding cell masks have to match in size. For multichannel images, the number of rows in the panel (exluding column headers) has to match the number of image channels. Images and cell masks are matched by filename (alphabetical order). Source and target data are matched by filename (alphabetical order). Source and target images/cell masks do not have to have the same size, scale (pixel size), or number of channels. Source panel and target panel can share channels, but do not have to. Tasks \u00b6 For convenience, multiple steps are combined into tasks . For each task, spellmatch provides a dedicated command . The individual tasks and commands are described on the following pages. Image registration Interactive cell matching Feature-based image registration Intensity-based image registration Spatial cell matching Cell assignment Output \u00b6 Spellmatch produces the following output data: Projective transformations (3x3 numpy array, stored as numpy .npy files) Note: geometric transforms are computed from centered masks/images Cell alignment scores (xarray DataArray, stored as netCDF .nc files) Shape: source labels x target labels, data type: floating point Cell assignments (CSV files holding cell label pairs) Column headers: Source (source cell label), Target (target cell label) By default, all files are named {source}_to_{target}.{suffix} , where {source} is the source image/cell mask name and {target} is the target image/cell mask name.","title":"Introduction"},{"location":"usage/#introduction","text":"In this chapter, the usage of spellmatch is introduced by example. The dataset being showcased can be found in the spellmatch repository (subset of Kuett & Catena et al, 2021).","title":"Introduction"},{"location":"usage/#workflow","text":"The following flowchart illustrates the spellmatch workflow. Blue rectangles indicate steps , yellow boxes represent modules . Cylinders indicate input and output data of the workflow. flowchart TB source_data[(\"Source data<br>(masks, images, panel)\")] --> initial_registration target_data[(\"Target data<br>(masks, images, panel)\")] --> initial_registration subgraph Registration initial_registration[\"Interactive cell matching\"] refined_registration[\"Feature/intensity-based<br>image registration\"] initial_registration -->|\"initial transform\"| refined_registration end source_data --> matching refined_registration -->|\"refined transform<br>(spatial prior, optional)\"| matching target_data --> matching subgraph Spatial cell matching matching[Automatic cell matching] transform_update[\"Transform estimation<br>(iterative algorithms)\"] matching -->|cell alignment scores| transform_update transform_update -->|updated transform| matching end initial_registration -->|\"partial assignment<br>(for validation, optional)\"| assignment matching -->|alignment scores| assignment assignment[\"Cell assignment\"] assignment --> cell_pairs[(\"Cell assignment\")]","title":"Workflow"},{"location":"usage/#usage","text":"Spellmatch can be used from the command-line (terminal in Linux/MacOS, console in Windows): \u276f spellmatch --help Usage: spellmatch [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. Commands: ... ... Most spellmatch commands support a -v option for enabling more verbose output. In addition, many spellmatch commands support a --show option for visualizing the current operation. At any point, use the --help option to display additional information about a specific command. All spellmatch commands can operate on individual file pairs as well as on entire directories.","title":"Usage"},{"location":"usage/#input","text":"Spellmatch requires pairs of source data and target data, where source/target data consist of: Cell masks (TIFF files of any data type) Single- or multichannel images (TIFF files of any data type, optional) For multichannel images: panel with channel information (CSV files, in channel order) Column headers: name (channel name, unique), keep ( 0 or 1 , optional) Images and corresponding cell masks have to match in size. For multichannel images, the number of rows in the panel (exluding column headers) has to match the number of image channels. Images and cell masks are matched by filename (alphabetical order). Source and target data are matched by filename (alphabetical order). Source and target images/cell masks do not have to have the same size, scale (pixel size), or number of channels. Source panel and target panel can share channels, but do not have to.","title":"Input"},{"location":"usage/#tasks","text":"For convenience, multiple steps are combined into tasks . For each task, spellmatch provides a dedicated command . The individual tasks and commands are described on the following pages. Image registration Interactive cell matching Feature-based image registration Intensity-based image registration Spatial cell matching Cell assignment","title":"Tasks"},{"location":"usage/#output","text":"Spellmatch produces the following output data: Projective transformations (3x3 numpy array, stored as numpy .npy files) Note: geometric transforms are computed from centered masks/images Cell alignment scores (xarray DataArray, stored as netCDF .nc files) Shape: source labels x target labels, data type: floating point Cell assignments (CSV files holding cell label pairs) Column headers: Source (source cell label), Target (target cell label) By default, all files are named {source}_to_{target}.{suffix} , where {source} is the source image/cell mask name and {target} is the target image/cell mask name.","title":"Output"},{"location":"usage/assignment/","text":"Cell assignment \u00b6 Under construction This page is still under construction. Cell assignment \u00b6 spellmatch assign","title":"Cell assignment"},{"location":"usage/assignment/#cell-assignment","text":"Under construction This page is still under construction.","title":"Cell assignment"},{"location":"usage/assignment/#cell-assignment_1","text":"spellmatch assign","title":"Cell assignment"},{"location":"usage/matching/","text":"Spatial cell matching \u00b6 Under construction This page is still under construction. Automatic cell matching \u00b6 spellmatch match","title":"Spatial cell matching"},{"location":"usage/matching/#spatial-cell-matching","text":"Under construction This page is still under construction.","title":"Spatial cell matching"},{"location":"usage/matching/#automatic-cell-matching","text":"spellmatch match","title":"Automatic cell matching"},{"location":"usage/registration/","text":"Image registration \u00b6 Under construction This page is still under construction. Interactive cell matching \u00b6 spellmatch register interactive Feature-based image registration \u00b6 spellmatch register features Intensity-based image registration \u00b6 spellmatch register intensities","title":"Image registration"},{"location":"usage/registration/#image-registration","text":"Under construction This page is still under construction.","title":"Image registration"},{"location":"usage/registration/#interactive-cell-matching","text":"spellmatch register interactive","title":"Interactive cell matching"},{"location":"usage/registration/#feature-based-image-registration","text":"spellmatch register features","title":"Feature-based image registration"},{"location":"usage/registration/#intensity-based-image-registration","text":"spellmatch register intensities","title":"Intensity-based image registration"}]}